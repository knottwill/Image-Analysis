# Sample code
#from __future__  import division

import numpy             as np




## Iterate thresholding sample code
#import numpy             as np
#import matplotlib.pyplot as plt
#import scipy.fftpack     as spfft # For an illustration of the frequency
#import scipy.optimize    as scopt # For minimizing objective functions with constraints
#import cvxpy             as cvx   # Library for convex optimization
#import pywt                       # Wavelet transform software 

#from IPython     import display
#from skimage     import data, io, filters


#for i in range(0,niter):
    # SoftThreshold and Data consistency
#    xi = np.fft.ifft(...  )     # Compute the inverse Fourier transform to get an estimate of the signal
#    xi_st = SoftThresh(...,...) # Softhreshold the signal in the signal domain
#    Xi = np.fft.fft(... )       # ComputetheFouriertransform
#    Xi =  Xi * (Y==0) + Y      # Enforce data consistency in the frequency domain: filling missed k-space points 

    # Plot
#    plt.clf()
#    plt.figure( figsize = (9,3))
#    plt.stem(...)
#    plt.title( 'Iteration %d' % i)
#    display.clear_output(wait=True)
#    display.display(plt.gcf ())
#    ###plt.show()
# plt.savefig("your_figure_name.png")





## Helper routines to visualize wavelets with pywavelets

def imshowgray(im, vmin=None, vmax=None):
    plt.imshow(im, cmap=plt.get_cmap('gray'), vmin=vmin, vmax=vmax)

def wavMask(dims, scale):
    sx, sy = dims
    res = np.ones(dims)
    NM = np.round(np.log2(dims))
    for n in range(int(np.min(NM)-scale+2)//2):
        res[:int(np.round(2**(NM[0]-n))), :int(np.round(2**(NM[1]-n)))] = \
            res[:int(np.round(2**(NM[0]-n))), :int(np.round(2**(NM[1]-n)))]/2
    return res


def imshowWAV(Wim, scale=1):
    plt.imshow(np.abs(Wim)*wavMask(Wim.shape, scale), cmap = plt.get_cmap('gray'))

    
def coeffs2img(LL, coeffs):
    LH, HL, HH = coeffs
    return np.vstack((np.hstack((LL, LH)), np.hstack((HL, HH))))


def unstack_coeffs(Wim):
        L1, L2  = np.hsplit(Wim, 2) 
        LL, HL = np.vsplit(L1, 2)
        LH, HH = np.vsplit(L2, 2)
        return LL, [LH, HL, HH]

    
def img2coeffs(Wim, levels=4):
    LL, c = unstack_coeffs(Wim)
    coeffs = [c]
    for i in range(levels-1):
        LL, c = unstack_coeffs(LL)
        coeffs.insert(0,c)
    coeffs.insert(0, LL)
    return coeffs
    

def dwt1(im):
    coeffs = pywt.wavedec(im, wavelet='db4', mode='per', level=4)
    Wim, rest = coeffs[0], coeffs[1:]
    for levels in rest:
        Wim = coeffs2img(Wim, levels)
    return Wim


def dwt2(im):
    coeffs = pywt.wavedec2(im, wavelet='db4', mode='per', level=4)
    Wim, rest = coeffs[0], coeffs[1:]
    for levels in rest:
        Wim = coeffs2img(Wim, levels)
    return Wim


def idwt2(Wim):
    coeffs = img2coeffs(Wim, levels=4)
    return pywt.waverec2(coeffs, wavelet='db4', mode='per')

def WimTh(Wim,f):
    m =  np.sort(abs(Wim.ravel()))[::-1]
    ndx = int(len(m)*f)
    thr = m[ndx]
    Wim_th = Wim*(abs(Wim)>thr)
    im_thr = idwt2(Wim_thr)
    return im_thr, Wim_thr
    
def SoftThresh(y, t): 
    #SoftThresh -- Apply Soft Threshold to y
    res = (abs(y) -t)
    res = (res +abs(res)) /2.
    y = np.sign(y) *res
    return y
